{
  "_args": [
    [
      {
        "raw": "tsjs",
        "scope": null,
        "escapedName": "tsjs",
        "name": "tsjs",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/Users/mmlapointe/Desktop/LAFF_edx/algos"
    ]
  ],
  "_from": "tsjs@latest",
  "_id": "tsjs@0.3.3",
  "_inCache": true,
  "_location": "/tsjs",
  "_nodeVersion": "7.10.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/tsjs-0.3.3.tgz_1516998015582_0.5670575362164527"
  },
  "_npmUser": {
    "name": "michelmoreaul",
    "email": "michmoreau.l@gmail.com"
  },
  "_npmVersion": "4.6.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "tsjs",
    "scope": null,
    "escapedName": "tsjs",
    "name": "tsjs",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#DEV:/",
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/tsjs/-/tsjs-0.3.3.tgz",
  "_shasum": "036eeea6b6047877b085b4be512eb59f1823302d",
  "_shrinkwrap": null,
  "_spec": "tsjs",
  "_where": "/Users/mmlapointe/Desktop/LAFF_edx/algos",
  "bin": {
    "tsjs": "tsjs.js"
  },
  "bugs": {
    "url": "https://github.com/coveo/tsjs/issues"
  },
  "dependencies": {
    "shelljs": "0.8.1",
    "tslint": "5.9.1",
    "typescript": "2.6.2",
    "yargs": "10.1.1"
  },
  "description": "A mostly reasonable approach to TypeScript and JavaScript.",
  "devDependencies": {},
  "directories": {},
  "dist": {
    "shasum": "036eeea6b6047877b085b4be512eb59f1823302d",
    "tarball": "https://registry.npmjs.org/tsjs/-/tsjs-0.3.3.tgz"
  },
  "gitHead": "0f93319a864484019b6170770b1f71d026af937b",
  "homepage": "https://github.com/coveo/tsjs#readme",
  "license": "MIT",
  "main": "tsjs.js",
  "maintainers": [
    {
      "name": "michelmoreaul",
      "email": "michmoreau.l@gmail.com"
    }
  ],
  "name": "tsjs",
  "optionalDependencies": {},
  "readme": "# TSJS  \n> Coveo TypeScript (and JavaScript) Cloud Platform Standards  \n  \nOther Standards  \n\n- [React/Redux](react_redux/)  \n- [CSS & Sass](css_sass/)\n\n<h2 id=\"intro\">Introduction</h2>\n\nThe current repository aggregates all code standards that must be respected when writing and reviewing TypeScript code related to the Coveo Cloud Platform. This document should therefore be read and applied by anyone having to write TypeScript code for the Coveo Cloud Platform.  \n  \nThe current repository is greatly inspired from [Airbnb's JavaScript Style Guide](https://github.com/airbnb/javascript), but most code examples were rewritten in TypeScript.  \n\nIf you are somewhat new to JavaScript with ES6, we recommend you read the full [Airbnb's JavaScript Style Guide](https://github.com/airbnb/javascript). Feel free to use additional resources, there are tons of it out there.\n\nIf you are somewhat new to TypeScript, we recommend you follow this [5 minutes tutorial](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html), and read the official [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/basic-types.html) in full.\n  \n<h3 id=\"intro--why\">Code standards, what for?</h3>\n\nAdopting code standards means ranking the importance of code clarity and team conventions higher than personal style. In a more pragmatical perspective, we also believe that code standards have very positive and tangible effects on a team workflow:  \n  1. __Team members get productive time back by avoiding subjective code style debates__. If the code doesn't respect team conventions, simply point the author to the commonly accepted code standard that must be respected. \n  1. __Code reviews' focus are redirected towards what is most critical:__ \n      1. _Code architecture_ (Is there a better/more intelligent way to handle the use case at hand?)\n      1. _Code fidelity_ (Will the code crash in real life situations? Are all possible cases handled?)  \n      1. _Code quality_ (Is the code well tested, meaningful, and DRY?) \n  1. __The code base gets easier to read and navigate for team members.__  \n  1. __Written standards (as opposed to implicit, word-to-mouth standards) allow newcomers to get up to speed faster by knowing how to write proper code from day one.__  \n  \nIn summary, code standards make developers happier. Embrace them.\n\n<h2 id=\"table-of-contents\">Table of Contents</h2>\n\n  1. [Types](#types)\n  1. [References](#references)\n  1. [Objects](#objects)\n  1. [Arrays](#arrays)\n  1. [Destructuring](#destructuring)\n  1. [Strings](#strings)\n  1. [Functions](#functions)\n  1. [Arrow Functions](#arrow-functions)\n  1. [Classes & Constructors](#classes--constructors)\n  1. [Modules](#modules)\n  1. [Iterators and Generators](#iterators-and-generators)\n  1. [Properties](#properties)\n  1. [Variables](#variables)\n  1. [Hoisting](#hoisting)\n  1. [Comparison Operators & Equality](#comparison-operators--equality)\n  1. [Blocks](#blocks)\n  1. [Control Statements](#control-statements)\n  1. [Comments](#comments)\n  1. [Whitespace](#whitespace)\n  1. [Commas](#commas)\n  1. [Semicolons](#semicolons)\n  1. [Type Casting & Coercion](#type-casting--coercion)\n  1. [Naming Conventions](#naming-conventions)\n  1. [Accessors](#accessors)\n  1. [Events](#events)\n  1. [jQuery](#jquery)\n  1. [ECMAScript 6+ (ES 2015+) Styles](#ecmascript-6-es-2015-styles)\n  1. [Testing](#testing)\n  1. [Reviewing](#reviewing)\n  1. [Being Reviewed](#being-reviewed)\n  1. [TypeScript](#typescript)\n  1. [Libraries and Frameworks](#libraries-and-frameworks)\n  1. [Notes on Legacy Code](#notes-on-legacy-code)\n  1. [Remaining Sections](#remaining-sections)\n\n## Types\n\nSince this part appeared to have a more educational purpose, you can refer to the original [Airbnb's JavaScript Style Guide](https://github.com/airbnb/javascript#types) for more information.  \n  \n\n**[⬆ back to top](#table-of-contents)**\n\n## References\n\n  <a name=\"references--prefer-const\"></a><a name=\"1.1\"></a>\n  - [1.1](#references--prefer-const) Use `const` for all of your references; avoid using `var`. \n\n    > Why? This ensures that you can't reassign your references, which can lead to bugs and difficult to comprehend code.\n\n    ```typescript\n    // bad\n    var a = 1;\n    var b = 2;\n\n    // good\n    const a = 1;\n    const b = 2;\n    ```\n\n  <a name=\"references--disallow-var\"></a><a name=\"1.2\"></a>\n  - [1.2](#references--disallow-var) If you must reassign references, use `let` instead of `var`. \n\n    > Why? `let` is block-scoped rather than function-scoped like `var`.\n\n    ```typescript\n    // bad\n    var count = 1;\n    if (true) {\n      count += 1;\n    }\n\n    // good, use the let.\n    let count = 1;\n    if (true) {\n      count += 1;\n    }\n    ```\n\n  <a name=\"references--block-scope\"></a><a name=\"1.3\"></a>\n  - [1.3](#references--block-scope) Note that both `let` and `const` are block-scoped.\n\n    ```typescript\n    // const and let only exist in the blocks they are defined in.\n    {\n      let a = 1;\n      const b = 1;\n    }\n    console.log(a); // ReferenceError\n    console.log(b); // ReferenceError\n    ```\n\n**[⬆ back to top](#table-of-contents)**\n\n## Objects\n\n  <a name=\"objects--no-new\"></a><a name=\"2.1\"></a>\n  - [2.1](#objects--no-new) Use the literal syntax for object creation. \n\n    ```typescript\n    // bad\n    const item: Interface = new Object();\n\n    // good\n    const item: Interface = { value: 1 };\n    ```\n  <a name=\"es6-object-shorthand\"></a><a name=\"2.2\"></a>\n  - [2.2](#es6-object-arrow-method) Methods defined on objects should use arrow functions. \n\n    ```typescript\n    // bad\n    const atom: Interface = {\n      value: 1,\n      addValue: function (value: number): number {\n        return atom.value + value;\n      },\n    };\n\n    // good\n    const atom: Interface = {\n      value: 1,\n      addValue: (value: number): number => value + 1,\n    };\n    ```\n\n  <a name=\"es6-object-concise\"></a><a name=\"2.3\"></a>\n  - [2.3](#es6-object-concise) Use property value shorthand. \n\n    > Why? It is shorter to write and descriptive.\n\n    ```typescript\n    const lukeSkywalker = 'Luke Skywalker';\n\n    // bad\n    const obj: Interface = {\n      lukeSkywalker: lukeSkywalker,\n    };\n\n    // good\n    const obj: Interface = {\n      lukeSkywalker,\n    };\n    ```\n\n  <a name=\"objects--grouped-shorthand\"></a><a name=\"2.4\"></a>\n  - [2.4](#objects--grouped-shorthand) Group your shorthand properties at the beginning of your object declaration.\n\n    > Why? It's easier to tell which properties are using the shorthand.\n\n    ```typescript\n    const anakinSkywalker = 'Anakin Skywalker';\n    const lukeSkywalker = 'Luke Skywalker';\n\n    // bad\n    const obj: Interface = {\n      episodeOne: 1,\n      twoJediWalkIntoACantina: 2,\n      lukeSkywalker,\n      episodeThree: 3,\n      mayTheFourth: 4,\n      anakinSkywalker,\n    };\n\n    // good\n    const obj: Interface = {\n      lukeSkywalker,\n      anakinSkywalker,\n      episodeOne: 1,\n      twoJediWalkIntoACantina: 2,\n      episodeThree: 3,\n      mayTheFourth: 4,\n    };\n    ```\n\n  <a name=\"objects--quoted-props\"></a><a name=\"2.5\"></a>\n  - [2.5](#objects--quoted-props) Only quote properties that are invalid identifiers. \n\n    > Why? In general we consider it subjectively easier to read. It improves syntax highlighting, and is also more easily optimized by many JS engines.\n\n    ```typescript\n    // bad\n    const bad: Interface = {\n      'foo': 3,\n      'bar': 4,\n      'data-blah': 5,\n    };\n\n    // good\n    const good: Interface = {\n      foo: 3,\n      bar: 4,\n      'data-blah': 5,\n    };\n    ```\n  <a name=\"objects--shallow-copy\"></a><a name=\"2.6\"></a>\n  - [2.6](#objects--shallow-copy) Use Underscore's [`extend`](http://underscorejs.org/#extend) and [`omit`](http://underscorejs.org/#omit) functions to shallow-copy objects, and make sure not to mutate the original object... \n\n    ```typescript\n    // very bad\n    const original: Interface = { a: 1, b: 2 };\n    const copy: Interface = _.extend(original, { c: 3 }); // this mutates `original` ಠ_ಠ\n    delete copy.a; // so does this\n\n    // good\n    const original: Interface = { a: 1, b: 2 };\n    const copy: Interface = _.extend({}, original, { c: 3 }); // copy => { a: 1, b: 2, c: 3 }\n\n    // good\n    const original: Interface = { a: 1, b: 2 };\n    const copy: Interface = _.omit(original, 'a'); // copy => { b: 2 }, _.omit does not mutate `original`\n    ```\n\n**[⬆ back to top](#table-of-contents)**\n\n## Arrays\n\n  <a name=\"arrays--literals\"></a><a name=\"3.1\"></a>\n  - [3.1](#arrays--literals) Use the literal syntax for array creation. \n\n    ```typescript\n    // bad\n    const items: Interface[] = new Array();\n\n    // good\n    const items: Interface[] = [];\n    ```\n  <a name=\"arrays--callback-return\"></a><a name=\"3.2\"></a>\n  - [3.2](#arrays--callback-return) Use return statements in array method callbacks. It's ok to omit the return if the function body consists of a single statement. We also encourage the use of the ternary operator in simple if/else cases. \n\n    ```typescript\n    // bad\n    [1, 2, 3].map((x: number): number => {\n      return x + 1;\n    });\n\n    // good\n    [1, 2, 3].map((x: number): number => x + 1);\n\n    // good\n    [1, 2, 3].map((x: number): number => {\n      const y = x + 1;\n      return x * y;\n    });\n\n    // good\n    inbox.filter((msg: string): boolean => {\n      if (msg.subject === 'Mockingbird') {\n        return msg.author === 'Harper Lee';\n      } else if (msg.subject === 'AnotherSubject') {\n        return msg.author === 'The Author';  \n      }\n\n      return false;\n    });\n\n\n    /* Simple if/else cases */\n\n    // bad\n    inbox.filter((msg: string): boolean => {\n      if (msg.subject === 'Mockingbird') {\n        return msg.author === 'Harper Lee';\n      } else {\n        return false;\n      }\n    });\n\n    // best \n    inbox.filter((msg: string): boolean => msg.subject === 'Mockingbird'\n        ? msg.author === 'Harper Lee'\n        : false\n    );\n    ```\n\n**[⬆ back to top](#table-of-contents)**\n\n<a name=\"arrays--bracket-newline\"></a><a name=\"3.3\"></a>\n  - [3.3](#arrays--bracket-newline) Use line breaks after open and before close array brackets if an array has multiple lines\n\n  ```typescript\n  // bad\n  const arr: number[][] = [\n    [0, 1], [2, 3], [4, 5],\n  ];\n\n  const objectInArray: Interface[] = [{\n    id: 1,\n  }, {\n    id: 2,\n  }];\n\n  const numberInArray: number[] = [\n    1, 2,\n  ];\n\n  // good\n  const arr: number[][] = [[0, 1], [2, 3], [4, 5]];\n\n  const objectInArray: Interface[] = [\n    {\n      id: 1,\n    },\n    {\n      id: 2,\n    },\n  ];\n\n  const numberInArray: number[] = [\n    1,\n    2,\n  ];\n  ```\n\n**[⬆ back to top](#table-of-contents)**\n\n## Destructuring\n\n\n  <a name=\"destructuring--object\"></a><a name=\"4.1\"></a>\n  - [4.1](#destructuring--object) Use object destructuring when accessing and using multiple properties of an object. \n\n    > Why? Destructuring saves you from creating temporary references for those properties.\n\n    ```typescript\n    // bad\n    const getFullName = (user: User): string => {\n      const firstName = user.personalInformation.firstName;\n      const lastName = user.personalInformation.lastName;\n\n      return `${firstName} ${lastName}`;\n    }\n\n    // good\n    const getFullName = (user: User): string => {\n      const { firstName, lastName } = user.personalInformation;\n      return `${firstName} ${lastName}`;\n    }\n    ```\n\n  <a name=\"destructuring--array\"></a><a name=\"4.2\"></a>\n  - [4.2](#destructuring--array) Use array destructuring.\n    ```typescript\n    const arr: number[] = [1, 2, 3, 4];\n\n    // bad\n    const first: number = arr[0];\n    const second: number = arr[1];\n\n    // good\n    const [first, second] = arr;\n    ```\n\n  <a name=\"destructuring--object-over-array\"></a><a name=\"4.3\"></a>\n  - [4.3](#destructuring--object-over-array) Use object destructuring for multiple return values, not array destructuring.\n    > Why? You can add new properties over time or change the order of things without breaking call sites.\n\n    ```typescript\n    // bad\n    const processInput = (input: Input): ProcessedInput => {\n      // then a miracle occurs\n      return [left, right, top, bottom];\n    }\n\n    // the caller needs to think about the order of return data\n    const [left, __, top] = processInput(input);\n\n    // good\n    const processInput = (input: Input): ProcessedInput => {\n      // then a miracle occurs\n      return { left, right, top, bottom };\n    }\n\n    // the caller selects only the data they need\n    const { left, top } = processInput(input);\n\n**[⬆ back to top](#table-of-contents)**\n\n## Strings\n\n  <a name=\"strings--quotes\"></a><a name=\"5.1\"></a>\n  - [5.1](#strings--quotes) Use single quotes `''` for strings. \n\n    ```typescript\n    // bad\n    const name: string = \"Capt. Janeway\";\n\n    // bad - template literals should contain interpolation or newlines\n    const name: string = `Capt. Janeway`;\n\n    // good\n    const name: string = 'Capt. Janeway';\n    ```\n\n  <a name=\"strings--line-length\"></a><a name=\"5.2\"></a>\n  - [5.2](#strings--line-length) Strings that cause the line to go over 140 characters should not be written across multiple lines using string concatenation.\n\n    > Why? Broken strings are painful to work with and make code less searchable.\n\n    ```typescript\n    // bad\n    const errorMessage: string = 'This is a super long error that was thrown because \\\n    of Batman. When you stop to think about how Batman had anything to do \\\n    with this, you would get nowhere \\\n    fast.';\n\n    // bad\n    const errorMessage: string = 'This is a super long error that was thrown because ' +\n      'of Batman. When you stop to think about how Batman had anything to do ' +\n      'with this, you would get nowhere fast.';\n\n    // good\n    const errorMessage: string = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';\n    ```\n\n  <a name=\"es6-template-literals\"></a><a name=\"5.3\"></a>\n  - [5.3](#es6-template-literals) When programmatically building up strings, use template strings instead of concatenation. \n\n    > Why? Template strings give you a readable, concise syntax with proper newlines and string interpolation features.\n\n    ```typescript\n    // bad\n    const sayHi = (name: string): string => 'How are you, ' + name + '?';\n\n    // bad\n    const sayHi = (name: string): string => ['How are you, ', name, '?'].join();\n\n    // bad\n    const sayHi = (name: string): string => `How are you, ${ name }?`;\n\n    // good\n    const sayHi = (name: string): string => `How are you, ${name}?`;\n    ```\n\n  <a name=\"strings--escaping\"></a><a name=\"5.4\"></a>\n  - [5.4](#strings--escaping) Do not unnecessarily escape characters in strings. \n\n    > Why? Backslashes harm readability, thus they should only be present when necessary.\n\n    ```typescript\n    // bad\n    const foo: string = '\\'this\\' \\i\\s \\\"quoted\\\"';\n\n    // good\n    const foo: string = `'this' is \"quoted\"`;\n    const foo: string = `my name is '${name}'`;\n    ```\n\n  <a name=\"strings--localization\"></a><a name=\"5.5\"></a>\n  - [5.5](#strings--localization) Never hardcode a string that will appear in the UI in the code base. Localize the string in a dedicated json file. \n\n    > Why? Coveo develops international products, strings appearing in the UI can be translated in multiple languages, thus we localize them.\n\n**[⬆ back to top](#table-of-contents)**\n\n## Functions\n\n  <a name=\"functions--declarations\"></a><a name=\"6.1\"></a>\n  - [6.1](#functions--declarations) Use named function expressions instead of function declarations. Prefer arrow functions if you do not absolutely need `function` to retrieve the proper `this` context. Most importantly, define functions as a method inside a class whenever possible.  \n    > Why? Function declarations are hoisted, which means that it’s easy - too easy - to reference the function before it is defined in the file. This harms readability and maintainability. If you find that a function’s definition is large or complex enough that it is interfering with understanding the rest of the file, then perhaps it’s time to extract it to its own module! \n\n    ```typescript\n    // bad\n    const foo = function (bar: Interface): ReturnedInterface {\n      // ...\n    };\n\n    // bad\n    const foo = function bar(bar: Interface): ReturnedInterface {\n      // ...\n    };\n\n    // good\n    const foo = (bar: Interface): ReturnedInterface => {\n      // ...\n    };\n\n    // best (declare functions as methods inside classes)\n    class MyClass {\n      foo(bar: Interface): ReturnedInterface {\n        // ...\n      }\n    }\n    ```  \n\n  <a name=\"functions--arguments-shadow\"></a><a name=\"6.2\"></a>\n  - [6.2](#functions--arguments-shadow) Never name a parameter `arguments`. This will take precedence over the `arguments` object that is given to every function scope.\n\n    ```typescript\n    // bad\n    const foo = (name: string, options: Options, arguments: Arguments): ReturnedInterface => {\n      // ...\n    };\n\n    // good\n    const foo = (name: string, options: Options, args: Arguments): ReturnedInterface => {\n      // ...\n    };\n    ```\n\n  <a name=\"es6-default-parameters\"></a><a name=\"6.3\"></a>\n  - [6.3](#es6-default-parameters) Use default parameter syntax rather than mutating function arguments.\n\n    ```typescript\n    // really bad\n    const handleThings = (options?: Options): ReturnedInterface {\n      // No! We shouldn't mutate function arguments.\n      // Double bad: if opts is falsy it'll be set to an object which may\n      // be what you want but it can introduce subtle bugs.\n      options = options || {};\n      // ...\n    };\n\n    // still bad\n    const handleThings = (options?: Options): ReturnedInterface => {\n      if (options === void 0) {\n        options = {};\n      }\n      // ...\n    };\n\n    // good\n    const handleThings = (options: Options = {}): ReturnedInterface => {\n      // ...\n    };\n    ```\n  <a name=\"functions--reassign-params\"></a><a name=\"6.4\"></a>\n  - [6.4](#functions--reassign-params) Never reassign parameters. \n\n    > Why? Reassigning parameters can lead to unexpected behavior, especially when accessing the `arguments` object. It can also cause optimization issues, especially in V8.\n\n    ```typescript\n    // bad\n    const f1 = (a: number) => {\n      a = 1;\n      // ...\n    };\n\n    const f2 = (a?: number) => {\n      if (!a) { a = 1; }\n      // ...\n    };\n\n    // good\n    const f3 = (a?: number) => {\n      const b: number = a || 1;\n      // ...\n    };\n\n    const f4 = (a: number = 1) => {\n      // ...\n    };\n    ```\n\n  <a name=\"functions--spread-vs-apply\"></a><a name=\"6.5\"></a>\n  - [6.5](#functions--spread-vs-apply) Prefer the use of the spread operator `...` to call variadic functions. \n\n    > Why? It's cleaner, you don't need to supply a context, and you can not easily compose `new` with `apply`.\n\n    ```typescript\n    // bad\n    const x: number[] = [1, 2, 3, 4, 5];\n    console.log.apply(console, x);\n\n    // good\n    const x: number[] = [1, 2, 3, 4, 5];\n    console.log(...x);\n\n    // bad\n    new (Function.prototype.bind.apply(Date, [null, 2016, 8, 5]));\n\n    // good\n    new Date(...[2016, 8, 5]);\n    ```\n\n  <a name=\"functions--signature-invocation-indentation\"></a><a name=\"6.6\"></a>\n  - [6.6](#functions--signature-invocation-indentation) Functions with multiline signatures, or invocations, should be indented just like every other multiline list in this guide: with each item on a line by itself, with a trailing comma on the last item.\n\n    ```typescript\n    // bad\n    const foo = (bar: string,\n                 baz: number,\n                 quux: number) => {\n      // ...\n    }\n\n    // good\n    const foo = (\n      bar: string,\n      baz: number,\n      quux: number,\n    ) => {\n      // ...\n    }\n\n    // bad\n    console.log(foo,\n      bar,\n      baz);\n\n    // good\n    console.log(\n      foo,\n      bar,\n      baz,\n    );\n    ```\n\n**[⬆ back to top](#table-of-contents)**\n\n## Arrow Functions\n\n  <a name=\"arrows--use-them\"></a><a name=\"7.1\"></a>\n  - [7.1](#arrows--use-them) When you must use function expressions (as when passing an anonymous function), use arrow function notation. \n    > Why? It creates a version of the function that executes in the context of `this`, which is usually what you want, and is a more concise syntax. Only use `function` if really needed.\n\n    > Why not? If you have a fairly complicated function, you might move that logic out into its own function declaration.\n\n    ```typescript\n    // bad \n    [1, 2, 3].map(function (x: number): number {\n      const y: number = x + 1;\n      return x * y;\n    });\n\n    // good\n    [1, 2, 3].map((x: number): number => {\n      const y: number = x + 1;\n      return x * y;\n    });\n    ```\n\n  <a name=\"arrows--implicit-return\"></a><a name=\"7.2\"></a>\n  - [7.2](#arrows--implicit-return) If the function body consists of a single expression, omit the braces and use the implicit return. Otherwise, keep the braces and use a `return` statement. \n\n    > Why? Syntactic sugar. It reads well when multiple functions are chained together.\n\n    ```typescript\n    // bad\n    [1, 2, 3].map((x: number): string => {\n      const nextValue: number = x + 1;\n      `A string containing the ${nextValue}.`;\n    });\n\n    // good\n    [1, 2, 3].map((x: number): string => `A string containing the ${x}.`);\n\n    // good\n    [1, 2, 3].map((x: number): string => {\n      const nextValue: number = x + 1;\n      return `A string containing the ${nextValue}.`;\n    });\n\n    // good\n    [1, 2, 3].map((x: number, index: number): {[key: number]: number} => ({\n      [index]: x,\n    }));\n    ```\n\n  <a name=\"arrows--paren-wrap\"></a><a name=\"7.3\"></a>\n  - [7.3](#arrows--paren-wrap) In case the expression spans over multiple lines, wrap it in parentheses for better readability.\n\n    > Why? It shows clearly where the function starts and ends.\n\n    ```typescript\n    // bad\n    ['get', 'post', 'put'].map((httpMethod: string): ReturnedInterface => Object.prototype.hasOwnProperty.call(\n        httpMagicObjectWithAVeryLongName,\n        httpMethod,\n      )\n    );\n\n    // good\n    ['get', 'post', 'put'].map((httpMethod: string): boolean => (\n      Object.prototype.hasOwnProperty.call(\n        httpMagicObjectWithAVeryLongName,\n        httpMethod,\n      )\n    ));\n    ```\n\n  <a name=\"arrows--one-arg-parens\"></a><a name=\"7.4\"></a>\n  - [7.4](#arrows--one-arg-parens) Always include parentheses around arguments for clarity and consistency.\n    > Why? Less visual clutter. Scopes the parameter with its type.\n\n    ```typescript\n    // bad (not even possible in TypeScript with typed parameters)\n    [1, 2, 3].map(x: number => (\n      `A long string with the ${x}. It’s so long that we don’t want it to take up space on the .map line!`\n    ));\n\n    // good\n    [1, 2, 3].map((x: number): string => (\n      `A long string with the ${x}. It’s so long that we don’t want it to take up space on the .map line!`\n    ));\n    ```\n\n  <a name=\"arrows--confusing\"></a><a name=\"7.5\"></a>\n  - [7.5](#arrows--confusing) Avoid confusing arrow function syntax (`=>`) with comparison operators (`<=`, `>=`). \n\n    ```typescript\n    // bad\n    const itemHeight = (item: Item): string => item.height > 256 ? item.largeSize : item.smallSize;\n\n    // good\n    const itemHeight = (item: Item): string => (item.height > 256 ? item.largeSize : item.smallSize);\n\n    // good\n    const itemHeight = (item: Item): string => {\n      const { height, largeSize, smallSize } = item;\n      return height > 256 ? largeSize : smallSize;\n    };\n    ```\n\n**[⬆ back to top](#table-of-contents)**\n\n## Classes & Constructors\n\n  <a name=\"constructors--use-class\"></a><a name=\"8.1\"></a>\n  - [8.1](#constructors--use-class) Always use `class`. Avoid manipulating `prototype` directly.\n\n    > Why? `class` syntax is more concise and easier to reason about.\n\n    ```typescript\n    // bad\n    function Queue(contents: any[] = []) {\n      this.queue = [...contents];\n    }\n    Queue.prototype.pop = function () {\n      const value: any = this.queue[0];\n      this.queue.splice(0, 1);\n      return value;\n    };\n\n    // good\n    class Queue {\n      constructor(contents: any[] = []) {\n        this.queue = [...contents];\n      }\n      pop() {\n        const value: any = this.queue[0];\n        this.queue.splice(0, 1);\n        return value;\n      }\n    }\n    ```\n\n  <a name=\"constructors--extends\"></a><a name=\"8.2\"></a>\n  - [8.2](#constructors--extends) Use `extends` for inheritance.\n\n    > Why? It is a built-in way to inherit prototype functionality without breaking `instanceof`.\n\n    ```typescript\n    // bad\n    const inherits = require('inherits');\n    function PeekableQueue(contents) {\n      Queue.apply(this, contents);\n    }\n    inherits(PeekableQueue, Queue);\n    PeekableQueue.prototype.peek = () => this.queue[0];\n\n    // good\n    class PeekableQueue extends Queue {\n      peek() {\n        return this.queue[0];\n      }\n    }\n    ```\n\n  <a name=\"constructors--chaining\"></a><a name=\"8.3\"></a>\n  - [8.3](#constructors--chaining) Methods can return `this` to help with method chaining.\n\n    ```typescript\n    // bad\n    Jedi.prototype.jump = function (): boolean {\n      this.jumping = true;\n      return true;\n    };\n\n    Jedi.prototype.setHeight = function (height: number) {\n      this.height = height;\n    };\n\n    const luke: Jedi = new Jedi();\n    luke.jump(); // => true\n    luke.setHeight(20); // => undefined\n\n    // good\n    class Jedi {\n      private jumping: boolean;\n      private height: number;\n\n      jump(): Jedi {\n        this.jumping = true;\n        return this;\n      }\n\n      setHeight(height: number): Jedi {\n        this.height = height;\n        return this;\n      }\n    }\n\n    const luke: Jedi = new Jedi();\n\n    luke\n      .jump()\n      .setHeight(20);\n    ```\n\n  <a name=\"constructors--tostring\"></a><a name=\"8.4\"></a>\n  - [8.4](#constructors--tostring) It's okay to write a custom toString() method, just make sure it works successfully and causes no side effects.\n\n    ```typescript\n    class Jedi {\n      private name: string;\n\n      constructor(options: Options = {}) {\n        this.name = options.name || 'no name';\n      }\n\n      getName(): string {\n        return this.name;\n      }\n\n      toString(): string {\n        return `Jedi - ${this.getName()}`;\n      }\n    }\n    ```\n\n  <a name=\"constructors--no-useless\"></a><a name=\"8.5\"></a>\n  - [8.5](#constructors--no-useless) Classes have a default constructor if one is not specified. An empty constructor function or one that just delegates to a parent class is unnecessary. \n\n    ```typescript\n    // bad\n    class Jedi {\n      constructor() {}\n\n      // ...\n    }\n\n    // bad\n    class Rey extends Jedi {\n      constructor(options: Options) {\n        super(options);\n      }\n\n      // ...\n    }\n\n    // good\n    class Rey extends Jedi {\n      private name: string;\n\n      constructor(options: Options) {\n        super(options: Options);\n        this.name = 'Rey';\n      }\n    }\n    ```\n\n**[⬆ back to top](#table-of-contents)**\n\n## Modules\n\n  <a name=\"modules--use-them\"></a><a name=\"9.1\"></a>\n  - [9.1](#modules--use-them) Always use modules (`import`/`export`) over a non-standard module system.\n\n    > Why? Modules are the future, let's start using the future now.\n\n    ```typescript\n    // bad\n    const AirbnbStyleGuide = require('./AirbnbStyleGuide');\n    module.exports = AirbnbStyleGuide.es6;\n\n    // best\n    import { es6 } from './AirbnbStyleGuide';\n    export es6;\n    ```\n\n  <a name=\"modules--no-wildcard\"></a><a name=\"9.2\"></a>\n  - [9.2](#modules--no-wildcard) Do not use wildcard (unless you're forced to) or default imports/exports.\n\n    > Why? This makes sure you have a single default export.\n\n    ```typescript\n    // bad\n    import * as AirbnbStyleGuide from './AirbnbStyleGuide';\n\n    // bad\n    export default AirbnbStyleGuide; // inside one file\n\n    import AirbnbStyleGuide from './AirbnbStyleGuide'; inside another file\n\n    // good \n    export AirbnbStyleGuide; // inside one file\n\n    import { AirbnbStyleGuide } from './AirbnbStyleGuide'; // inside another file\n    ```\n\n  <a name=\"modules--no-export-from-import\"></a><a name=\"9.3\"></a>\n  - [9.3](#modules--no-export-from-import) And do not export directly from an import.\n\n    > Why? Although the one-liner is concise, having one clear way to import and one clear way to export makes things consistent.\n\n    ```typescript\n    // bad\n    // filename es6.ts\n    export { es6 } from './AirbnbStyleGuide';\n\n    // good\n    // filename es6.ts\n    import { es6 } from './AirbnbStyleGuide';\n    export es6;\n    ```\n\n  <a name=\"modules--no-duplicate-imports\"></a>\n  - [9.4](#modules--no-duplicate-imports) Only import from a path in one place, and each import should be on its own line.\n \n    > Why? Having multiple lines that import from the same path can make code harder to maintain.\n\n    ```typescript\n    // bad\n    import { named1 } from 'foo';\n    // … some other imports … //\n    import { named2 } from 'foo';\n\n    // bad\n    import { named1, named2 } from 'foo';\n\n    // \n    import foo, {\n      named1,\n      named2,\n    } from 'foo';\n    ```\n\n  <a name=\"modules--no-mutable-exports\"></a>\n  - [9.5](#modules--no-mutable-exports) Do not export mutable bindings.\n \n    > Why? Mutation should be avoided in general, but in particular when exporting mutable bindings. While this technique may be needed for some special cases, in general, only constant references should be exported.\n\n    ```typescript\n    // bad\n    export let foo: number = 3;\n\n    // good\n    export const foo: number = 3;\n    ```\n  <a name=\"modules--imports-first\"></a>\n  - [9.6](#modules--imports-first) Put all `import`s above non-import statements.\n \n    > Why? Since `import`s are hoisted, keeping them all at the top prevents surprising behavior.\n\n    ```typescript\n    // bad\n    import { foo } from 'foo';\n    foo.init();\n\n    import { bar } from 'bar';\n\n    // good\n    import { foo } from 'foo';\n    import { bar } from 'bar';\n\n    foo.init();\n    ```\n\n  <a name=\"modules--multiline-imports-over-newlines\"></a>\n  - [9.7](#modules--multiline-imports-over-newlines) Multiline imports should be indented just like multiline array and object literals.\n\n    > Why? The curly braces follow the same indentation rules as every other curly brace block in the style guide, as do the trailing commas.\n\n    ```typescript\n    // bad\n    import {longNameA, longNameB, longNameC, longNameD, longNameE} from 'path';\n\n    // good\n    import {\n      longNameA,\n      longNameB,\n      longNameC,\n      longNameD,\n      longNameE,\n    } from 'path';\n    ```\n\n**[⬆ back to top](#table-of-contents)**\n\n## Iterators and Generators\n\n  <a name=\"iterators--nope\"></a><a name=\"10.1\"></a>\n  - [10.1](#iterators--nope) Don't use iterators. Prefer JavaScript's higher-order functions instead of loops like `for-in` or `for-of`. \n\n    > Why? This enforces our immutable rule. Dealing with pure functions that return values is easier to reason about than side effects.\n\n    > Use `map()` / `every()` / `filter()` / `find()` / `findIndex()` / `reduce()` / `some()` / ... to iterate over arrays, and `Object.keys()` / `Object.values()` / `Object.entries()` to produce arrays so you can iterate over objects.\n\n    ```typescript\n    const numbers: number[] = [1, 2, 3, 4, 5];\n\n    // bad\n    let sum: number = 0;\n    for (let num: number of numbers) {\n      sum += num;\n    }\n    sum === 15;\n\n    // best (use the functional force)\n    const sum: number = numbers.reduce((total: number, num: number): number => total + num, 0);\n    sum === 15;\n\n    // bad\n    const increasedByOne: number[] = [];\n    for (let i: number = 0; i < numbers.length; i++) {\n      increasedByOne.push(numbers[i] + 1);\n    }\n\n    // best (keeping it functional)\n    const increasedByOne: number[] = numbers.map((num: number): number => num + 1);\n    ```\n\n  <a name=\"generators--nope\"></a><a name=\"10.2\"></a>\n  - [10.2](#generators--nope) Don't use generators for now.\n\n    > Why? They don't transpile well to ES5.\n\n**[⬆ back to top](#table-of-contents)**\n\n## Properties\n\n  <a name=\"properties--dot\"></a><a name=\"11.1\"></a>\n  - [11.1](#properties--dot) Use dot notation when accessing properties. \n\n    ```typescript\n    const luke: Interface = {\n      jedi: true,\n      age: 28,\n    };\n\n    // bad\n    const isJedi: boolean = luke['jedi'];\n\n    // good\n    const isJedi: boolean = luke.jedi;\n    ```\n\n  <a name=\"properties--bracket\"></a><a name=\"11.2\"></a>\n  - [11.2](#properties--bracket) Use bracket notation `[]` when accessing properties with a variable.\n\n    ```typescript\n    const luke: Interface = {\n      jedi: true,\n      age: 28,\n    };\n\n    const getProp = (prop: string) => luke[prop];\n\n    const isJedi: boolean = getProp('jedi');\n    ```\n\n**[⬆ back to top](#table-of-contents)**\n\n## Variables\n\n  <a name=\"variables--const\"></a><a name=\"12.1\"></a>\n  - [12.1](#variables--const) Always use `const` or `let` (not `var`) to declare variables. Not doing so will result in global variables. We want to avoid polluting the global namespace. Captain Planet warned us of that. \n\n    ```typescript\n    // bad\n    superPower: SuperPower = new SuperPower();\n\n    // good\n    const superPower: SuperPower = new SuperPower();\n    ```\n\n  <a name=\"variables--one-const\"></a><a name=\"12.2\"></a>\n  - [12.2](#variables--one-const) Use one `const` or `let` declaration per variable. \n\n    > Why? It's easier to add new variable declarations this way, and you never have to worry about swapping out a `;` for a `,` or introducing punctuation-only diffs. You can also step through each declaration with the debugger, instead of jumping through all of them at once.\n\n    ```typescript\n    // bad\n    const items: Item[] = getItems(),\n        goSportsTeam: boolean = true,\n        dragonball: string = 'z';\n\n    // bad\n    // (compare to above, and try to spot the mistake)\n    const items: Item[] = getItems(),\n        goSportsTeam: boolean = true;\n        dragonball: string = 'z';\n\n    // good\n    const items: Item[] = getItems();\n    const goSportsTeam: boolean = true;\n    const dragonball: string = 'z';\n    ```\n\n  <a name=\"variables--const-let-group\"></a><a name=\"12.3\"></a>\n  - [12.3](#variables--const-let-group) Group all your `const`s and then group all your `let`s.\n\n    > Why? This is helpful when later on you might need to assign a variable depending on one of the previous assigned variables.\n\n    ```typescript\n    // bad\n    const items: Item[] = getItems();\n    let dragonball: string;\n    const goSportsTeam: boolean = true;\n    let len: number;\n\n    // good\n    const goSportsTeam = true;\n    const items: Item[] = getItems();\n    let dragonball: string;\n    let len: number;\n    ```\n\n  <a name=\"variables--define-where-used\"></a><a name=\"12.4\"></a>\n  - [12.4](#variables--define-where-used) Assign variables where you need them, but place them in a reasonable place.\n\n    > Why? `let` and `const` are block scoped and not function scoped.\n\n    ```typescript\n    // bad - unnecessary function call\n    const checkName = (hasName: string): string|boolean => {\n      const name: string = getName();\n\n      if (hasName === 'test') {\n        return false;\n      }\n\n      if (name === 'test') {\n        this.setName('');\n        return false;\n      }\n\n      return name;\n    }\n\n    // good\n    const checkName = (hasName: string): string|boolean => {\n      if (hasName === 'test') {\n        return false;\n      }\n\n      const name: string = getName();\n\n      if (name === 'test') {\n        this.setName('');\n        return false;\n      }\n\n      return name;\n    }\n    ```\n  <a name=\"variables--unary-increment-decrement\"></a><a name=\"12.5\"></a>\n  - [12.5](#variables--unary-increment-decrement) Avoid using unary increments and decrements (++, --). \n\n    > Why? Disallowing unary increment and decrement statements prevents you from pre-incrementing/pre-decrementing values unintentionally which can also cause unexpected behavior in your programs.\n\n    ```typescript\n    // bad\n\n    const array: number[] = [1, 2, 3];\n    let num: number = 1;\n    num++;\n    --num;\n\n    let sum: number = 0;\n    let truthyCount: number = 0;\n    for (let i: number = 0; i < array.length; i++) {\n      let value: number = array[i];\n      sum += value;\n      if (value) {\n        truthyCount++;\n      }\n    }\n\n    // good\n\n    const array: number[] = [1, 2, 3];\n    let num: number = 1;\n    num += 1;\n    num -= 1;\n\n    const sum: number = array.reduce((a: number, b: number): number => a + b, 0);\n    const truthyCount: number = array.filter(Boolean).length;\n    ```\n\n**[⬆ back to top](#table-of-contents)**\n\n## Hoisting\n\n  Since this part appears to be more educational than anything else, you can refer to the original [Airbnb Style Guide](https://github.com/airbnb/javascript) for more information about hoisting. In short, use [`const`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/const) and [`let`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let), and always avoid using `var`. \n\n**[⬆ back to top](#table-of-contents)**\n\n## Comparison Operators & Equality\n\n  <a name=\"comparison--eqeqeq\"></a><a name=\"13.1\"></a>\n  - [13.1](#comparison--eqeqeq) Use `===` and `!==` over `==` and `!=`. \n\n  <a name=\"comparison--if\"></a><a name=\"13.2\"></a>\n  - [13.2](#comparison--if) Conditional statements such as the `if` statement evaluate their expression using coercion with the `ToBoolean` abstract method and always follow these simple rules:\n\n    - **Objects** evaluate to **true**\n    - **Undefined** evaluates to **false**\n    - **Null** evaluates to **false**\n    - **Booleans** evaluate to **the value of the boolean**\n    - **Numbers** evaluate to **false** if **+0, -0, or NaN**, otherwise **true**\n    - **Strings** evaluate to **false** if an empty string `''`, otherwise **true**\n\n    ```typescript\n    if ([0] && []) {\n      // true\n      // an array (even an empty one) is an object, objects will evaluate to true\n    }\n    ```\n\n  <a name=\"comparison--shortcuts\"></a><a name=\"13.3\"></a>\n  - [13.3](#comparison--shortcuts) Use shortcuts for conditionals as often as possible.\n\n    ```typescript\n    // bad\n    if (isValid === true) {\n      // ...\n    }\n\n    // good\n    if (isValid) {\n      // ...\n    }\n\n    // bad (unless you are testing for empty string only and not all falsy values)\n    if (name !== '') {\n      // ...\n    }\n\n    // good\n    if (name) {\n      // ...\n    }\n\n    // bad\n    if (collection.length > 0) {\n      // ...\n    }\n\n    // good\n    if (collection.length) {\n      // ...\n    }\n    ```\n\n  <a name=\"comparison--moreinfo\"></a><a name=\"13.4\"></a>\n  - [13.4](#comparison--moreinfo) For more information see [Truth Equality and JavaScript](https://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108) by Angus Croll.\n\n  <a name=\"comparison--switch-blocks\"></a><a name=\"13.5\"></a>\n  - [13.5](#comparison--switch-blocks) Use braces to create blocks in `case` and `default` clauses that contain lexical declarations (e.g. `let`, `const`, `function`, and `class`).\n\n    > Why? Lexical declarations are visible in the entire `switch` block but only get initialized when assigned, which only happens when its `case` is reached. This causes problems when multiple `case` clauses attempt to define the same thing.\n\n    ```typescript\n    // bad\n    switch (foo) {\n      case 1:\n        let x: number = 1;\n        break;\n      case 2:\n        const y: number = 2;\n        break;\n      case 3:\n        const f = () => {\n          // ...\n        };\n        break;\n      default:\n        class C {}\n    }\n\n    // good\n    switch (foo) {\n      case 1: {\n        let x: number = 1;\n        break;\n      }\n      case 2: {\n        const y: number = 2;\n        break;\n      }\n      case 3: {\n        const f = () => {\n          // ...\n        }\n        break;\n      }\n      case 4:\n        bar();\n        break;\n      default: {\n        class C {}\n      }\n    }\n    ```\n\n  <a name=\"comparison--nested-ternaries\"></a><a name=\"13.6\"></a>\n  - [13.6](#comparison--nested-ternaries) Ternaries should not be nested and generally be single line expressions.\n\n    ```typescript\n    // bad\n    const foo: string|null = maybe1 > maybe2\n      ? \"bar\"\n      : value1 > value2 ? \"baz\" : null;\n\n    // good\n    const maybeNull: string|null = value1 > value2 ? 'baz' : null;\n\n    const foo: string|null = maybe1 > maybe2\n      ? 'bar'\n      : maybeNull;\n    ```\n\n  <a name=\"comparison--unneeded-ternary\"></a><a name=\"13.7\"></a>\n  - [13.7](#comparison--unneeded-ternary) Avoid unneeded ternary statements.\n\n    ```typescript\n    // bad\n    const foo: Interface = a ? a : b;\n    const bar: boolean = c ? true : false;\n    const baz: boolean = c ? false : true;\n\n    // good\n    const foo: Interface = a || b;\n    const bar: boolean = !!c;\n    const baz: boolean = !c;\n    ```\n\n**[⬆ back to top](#table-of-contents)**\n\n## Blocks\n\n  <a name=\"blocks--braces\"></a><a name=\"14.1\"></a>\n  - [14.1](#blocks--braces) Always use braces for if/else blocks or functions with multiple statemets, and place statements on their own lines.\n\n    ```typescript\n    // bad\n    if (test)\n      return false;\n\n    if (test) return false;\n\n    // good\n    if (test) {\n      return false;\n    }\n\n    // bad\n    const foo = (): boolean => { const isTrue: boolean = true; return isTrue; };\n\n    // good\n    const bar = (): boolean => {\n      const isTrue: boolean = true;\n      return isTrue;\n    };\n\n    // good\n    const foo = (bar: boolean): boolean => bar;\n    ```\n\n  <a name=\"blocks--cuddled-elses\"></a><a name=\"14.2\"></a>\n  - [14.2](#blocks--cuddled-elses) If you're using multi-line blocks with `if` and `else`, put `else` on the same line as your `if` block's closing brace. \n\n    ```typescript\n    // bad\n    if (test) {\n      thing1();\n      thing2();\n    }\n    else {\n      thing3();\n    }\n\n    // good\n    if (test) {\n      thing1();\n      thing2();\n    } else {\n      thing3();\n    }\n    ```\n\n**[⬆ back to top](#table-of-contents)**\n\n## Control Statements\n\n  <a name=\"control-statements\"></a>\n  - [15.1](#control-statements) In case your control statement (`if`, `while` etc.) gets too long or exceeds the maximum line length, each (grouped) condition could be put into a new line. The logical operator should be placed at the beginning of the line.\n\n    ```typescript\n    // bad\n    if ((foo === 123 || bar === 'abc') && doesItLookGoodWhenItBecomesThatLong() && isThisReallyHappening()) {\n      thing1();\n    }\n\n    // bad\n    if ((foo === 123 || bar === \"abc\") &&\n        doesItLookGoodWhenItBecomesThatLong() &&\n        isThisReallyHappening()) {\n        thing1();\n    }\n\n    // good\n    if ((foo === 123 || bar === \"abc\")\n        && doesItLookGoodWhenItBecomesThatLong()\n        && isThisReallyHappening()) {\n        thing1();\n    }\n    ```\n\n**[⬆ back to top](#table-of-contents)**\n\n## Comments\n\n  <a name=\"comments--multiline\"></a><a name=\"16.1\"></a>\n  - [16.1](#comments--multiline) Use `/** ... */` for multi-line comments.\n\n    ```typescript\n    // bad\n    // make() returns a new element\n    // based on the passed in tag name\n    //\n    // @param {String} tag\n    // @return {Element} element\n    const make = (tag: string): Element => {\n\n      // ...\n\n      return element;\n    }\n\n    // good\n    /**\n     * make() returns a new element\n     * based on the passed-in tag name\n     */\n    const make = (tag: string): Element {\n\n      // ...\n\n      return element;\n    }\n    ```\n\n  <a name=\"comments--singleline\"></a><a name=\"16.2\"></a>\n  - [16.2](#comments--singleline) Use `//` for single line comments. Place single line comments on a newline above the subject of the comment. Put an empty line before the comment unless it's on the first line of a block.\n\n    ```typescript\n    // bad\n    const active: boolean = true;  // is current tab\n\n    // good\n    // is current tab\n    const active: boolean = true;\n\n    // bad\n    const getType = (): string => {\n      console.log('fetching type...');\n      // set the default type to 'no type'\n      const type: string = this.type || 'no type';\n\n      return type;\n    };\n\n    // good\n    const getType = (): string => {\n      console.log('fetching type...');\n\n      // set the default type to 'no type'\n      const type: string = this.type || 'no type';\n\n      return type;\n    };\n\n    // also good\n    const getType = (): string => {\n      // set the default type to 'no type'\n      const type: string = this.type || 'no type';\n\n      return type;\n    };\n    ```\n\n  <a name=\"comments--spaces\"></a><a name=\"16.3\"></a>\n  - [16.3](#comments--spaces) Start all comments with a space to make it easier to read. \n\n    ```typescript\n    // bad\n    //is current tab\n    const active: boolean = true;\n\n    // good\n    // is current tab\n    const active: boolean = true;\n\n    // bad\n    /**\n     *make() returns a new element\n     *based on the passed-in tag name\n     */\n    const make = (tag: string): Element {\n\n      // ...\n\n      return element;\n    };\n\n    // good\n    /**\n     * make() returns a new element\n     * based on the passed-in tag name\n     */\n    const make = (tag: string): Element {\n\n      // ...\n\n      return element;\n    };\n    ```\n\n  <a name=\"comments--actionitems\"></a><a name=\"16.4\"></a>\n  - [16.4](#comments--actionitems) Prefixing your comments with `TODO` helps other developers quickly understand if you're pointing out a problem that needs to be solved. Whenever possible, these comments should be supplemented with more context, like a linked story that can be specified by, for example, a JIRA issue number.\n\n    ```typescript\n    class Calculator extends Abacus {\n      private total: number;\n\n      constructor() {\n        super();\n\n        // TODO: total should be configurable by an options param - JIRA issue: UI-4312\n        this.total = 0;\n      }\n    }\n    ```\n\n**[⬆ back to top](#table-of-contents)**\n\n## Whitespace\n\n  <a name=\"whitespace--around-keywords\"></a><a name=\"17.1\"></a>\n  - [17.1](#whitespace--around-keywords) Place 1 space before the opening parenthesis in control statements (`if`, `while` etc.). Place no space between the argument list and the function name in function calls and declarations. \n\n    ```typescript\n    // bad\n    if(isJedi) {\n      fight ();\n    }\n\n    // good\n    if (isJedi) {\n      fight();\n    }\n\n    // bad\n    fight () {\n      console.log ('Swooosh!');\n    }\n\n    // good\n    fight() {\n      console.log('Swooosh!');\n    }\n    ```\n\n  <a name=\"whitespace--infix-ops\"></a><a name=\"17.2\"></a>\n  - [17.2](#whitespace--infix-ops) Set off operators with spaces. \n\n    ```typescript\n    // bad\n    const x: number=y+5;\n\n    // good\n    const x: number = y + 5;\n    ```\n\n  <a name=\"whitespace--newline-at-end\"></a><a name=\"17.3\"></a>\n  - [17.3](#whitespace--newline-at-end) End files with a single newline character. \n\n    ```typescript\n    // bad\n    import { es6 } from './AirbnbStyleGuide';\n      // ...\n    export es6;\n    ```\n\n    ```typescript\n    // bad\n    import { es6 } from './AirbnbStyleGuide';\n      // ...\n    export es6;↵\n    ↵\n    ```\n\n    ```typescript\n    // good\n    import { es6 } from './AirbnbStyleGuide';\n      // ...\n    export es6;↵\n    ```\n\n  <a name=\"whitespace--chains\"></a><a name=\"17.4\"></a>\n  - [17.4](#whitespace--chains) Use indentation when making long method chains (more than 2 method chains). Use a leading dot, which\n    emphasizes that the line is a method call, not a new statement. \n\n    ```typescript\n    // bad\n    $('#items').find('.selected').highlight().end().find('.open').updateCount();\n\n    // bad\n    $('#items').\n      find('.selected').\n      focus().\n      click();\n\n    // good\n    $('#items')\n      .find('.selected')\n      .focus()\n      .click();\n\n    // good\n    const leds: string = stage.selectAll('.led').data(data);\n    ```\n\n  <a name=\"whitespace--after-blocks\"></a><a name=\"17.5\"></a>\n  - [17.5](#whitespace--after-blocks) Leave a blank line after blocks and before the next statement. \n\n    ```typescript\n    // bad\n    if (foo) {\n      return bar;\n    }\n    return baz;\n\n    // good\n    if (foo) {\n      return bar;\n    }\n\n    return baz;\n\n    // bad\n    const obj: Interface = {\n      foo: () => {},\n      bar: () => {},\n    };\n    return obj;\n\n    // good\n    const obj: Interface = {\n      foo: () => {},\n      bar: () => {},\n    };\n\n    return obj;\n    ```\n\n  <a name=\"whitespace--padded-blocks\"></a><a name=\"17.6\"></a>\n  - [17.6](#whitespace--padded-blocks) Do not pad your blocks with blank lines. \n\n    ```typescript\n    // bad\n    bar() {\n\n      console.log(foo);\n\n    }\n\n    // also bad\n    if (baz) {\n\n      console.log(qux);\n    } else {\n      console.log(foo);\n\n    }\n\n    // good\n    bar() {\n      console.log(foo);\n    }\n\n    // good\n    if (baz) {\n      console.log(qux);\n    } else {\n      console.log(foo);\n    }\n    ```\n\n  <a name=\"whitespace--in-parens\"></a><a name=\"17.7\"></a>\n  - [17.7](#whitespace--in-parens) Do not add spaces inside parentheses. \n\n    ```typescript\n    // bad\n    bar( foo: Foo ): Foo {\n      return foo;\n    }\n\n    // good\n    bar(foo: Foo): Foo {\n      return foo;\n    }\n\n    // bad\n    if ( foo ) {\n      console.log(foo);\n    }\n\n    // good\n    if (foo) {\n      console.log(foo);\n    }\n    ```\n\n  <a name=\"whitespace--in-brackets\"></a><a name=\"17.8\"></a>\n  - [17.8](#whitespace--in-brackets) Do not add spaces inside brackets. \n\n    ```typescript\n    // bad\n    const foo: number[] = [ 1, 2, 3 ];\n    console.log(foo[ 0 ]);\n\n    // good\n    const foo: number[] = [1, 2, 3];\n    console.log(foo[0]);\n    ```\n\n  <a name=\"whitespace--in-braces\"></a><a name=\"17.9\"></a>\n  - [17.9](#whitespace--in-braces) Add spaces inside curly braces. \n\n    ```typescript\n    // bad\n    const foo: Interface = { clark: 'kent' };\n\n    // good\n    const foo: Interface = {clark: 'kent'};\n\n    ```\n\n  <a name=\"whitespace--max-len\"></a><a name=\"17.10\"></a>\n  - [17.10](#whitespace--max-len) Avoid having lines of code that are longer than 140 characters (including whitespace). If a line is to be broken, it should be broken at a meaningful position. If it barely exceeds 140 characters, you can leave it as is. Note: per [above](#strings--line-length), long strings are exempt from this rule, and should not be broken up. \n\n    > Why? This ensures readability and maintainability.\n\n    ```typescript\n    // bad\n    const foo: Interface = jsonData && jsonData.foo && jsonData.foo.bar && jsonData.foo.bar.baz && jsonData.foo.bar.baz.quux && jsonData.foo.bar.baz.quux.xyzzy;\n\n    // good\n    const foo: Interface = jsonData\n      && jsonData.foo\n      && jsonData.foo.bar\n      && jsonData.foo.bar.baz\n      && jsonData.foo.bar.baz.quux\n      && jsonData.foo.bar.baz.quux.xyzzy;\n\n    // bad\n    $.ajax({ method: 'POST', url: 'https://airbnb.com/', data: { name: 'John' } }).done(() => console.log('Congratulations!')).fail(() => console.log('You have failed this city.'));\n\n    // good\n    $.ajax({\n      method: 'POST',\n      url: 'https://airbnb.com/',\n      data: { name: 'John' },\n    })\n      .done(() => console.log('Congratulations!'))\n      .fail(() => console.log('You have failed this city.'));\n    ```\n\n**[⬆ back to top](#table-of-contents)**\n\n## Commas\n\n<a name=\"commas--leading-trailing\"></a><a name=\"18.1\"></a>\n  - [18.1](#commas--leading-trailing) Do not use leading commas, **use trailing commas**. \n\n    ```typescript\n    // bad\n    const story: Word[] = [\n        once\n      , upon\n      , aTime\n    ];\n\n    // good\n    const story: Word[] = [\n      once,\n      upon,\n      aTime,\n    ];\n\n    // bad\n    const hero: Hero = {\n        firstName: 'Ada'\n      , lastName: 'Lovelace'\n      , birthYear: 1815\n      , superPower: 'computers'\n    };\n\n    // good\n    const hero: Hero = {\n      firstName: 'Ada',\n      lastName: 'Lovelace',\n      birthYear: 1815,\n      superPower: 'computers',\n    };\n    ```\n\n  <a name=\"commas--dangling\"></a><a name=\"18.2\"></a>\n  - [18.2](#commas--dangling) Use the additional trailing comma. \n\n    > Why? This leads to cleaner git diffs. Also, transpilers like Babel will remove the additional trailing comma in the transpiled code which means you don't have to worry about the [trailing comma problem](https://github.com/airbnb/javascript/blob/es5-deprecated/es5/README.md#commas) in legacy browsers.\n\n    ```diff\n    // bad - git diff without trailing comma\n    const hero: Hero = {\n         firstName: 'Florence',\n    -    lastName: 'Nightingale'\n    +    lastName: 'Nightingale',\n    +    inventorOf: ['coxcomb chart', 'modern nursing']\n    };\n\n    // good - git diff with trailing comma\n    const hero: Hero = {\n         firstName: 'Florence',\n         lastName: 'Nightingale',\n    +    inventorOf: ['coxcomb chart', 'modern nursing'],\n    };\n    ```\n\n    ```typescript\n    // bad\n    const hero: Hero = {\n      firstName: 'Dana',\n      lastName: 'Scully'\n    };\n\n    const heroes: string[] = [\n      'Batman',\n      'Superman'\n    ];\n\n    // good\n    const hero: Hero = {\n      firstName: 'Dana',\n      lastName: 'Scully',\n    };\n\n    const heroes: string[] = [\n      'Batman',\n      'Superman',\n    ];\n\n    // bad\n    createHero(\n      firstName: string,\n      lastName: string,\n      inventorOf: string[]\n    ) {\n      // does nothing\n    }\n\n    // good\n    createHero(\n      firstName: string,\n      lastName: string,\n      inventorOf: string[],\n    ) {\n      // does nothing\n    }\n\n    // bad\n    createHero(\n      firstName: string,\n      lastName: string,\n      inventorOf: string[]\n    );\n\n    // good\n    createHero(\n      firstName: string,\n      lastName: string,\n      inventorOf: string[],\n    );\n\n    // good (note that a comma must not appear after a \"rest\" element)\n    createHero(\n      firstName: string,\n      lastName: string,\n      inventorOf: string[],\n      ...heroArgs\n    );\n    ```\n\n**[⬆ back to top](#table-of-contents)**\n\n## Semicolons\n\n  <a name=\"semicolons--required\"></a><a name=\"19.1\"></a>\n  - [19.1](#semicolons--required) **Use semicolons to end your code statements.** \n\n    ```typescript\n    // bad\n    ((): string {\n      const name: string = 'Skywalker'\n      return name\n    })()\n\n    // good\n    ((): string {\n      const name: string = 'Skywalker';\n      return name;\n    }());\n    ```\n**[⬆ back to top](#table-of-contents)**\n\n## Type Casting & Coercion\n\n  <a name=\"coercion--explicit\"></a><a name=\"20.1\"></a>\n  - [20.1](#coercion--explicit) Perform type coercion at the beginning of the statement.\n\n  <a name=\"coercion--strings\"></a><a name=\"20.2\"></a>\n  - [20.2](#coercion--strings)  Strings:\n\n    ```typescript\n    // => this.reviewScore = 9;\n\n    // bad\n    const totalScore: string = this.reviewScore + ''; // invokes this.reviewScore.valueOf()\n\n    // bad\n    const totalScore: string = this.reviewScore.toString(); // isn't guaranteed to return a string\n\n    // good\n    const totalScore: string = String(this.reviewScore);\n    ```\n\n  <a name=\"coercion--numbers\"></a><a name=\"20.3\"></a>\n  - [20.3](#coercion--numbers) Numbers: Use `Number` for type casting and `parseInt` always with a radix for parsing strings. \n\n    ```typescript\n    const inputValue: string = '4';\n\n    // bad\n    const val: number = new Number(inputValue);\n\n    // bad\n    const val: number = +inputValue;\n\n    // bad\n    const val: number = inputValue >> 0;\n\n    // bad\n    const val: number = parseInt(inputValue);\n\n    // good\n    const val: number = Number(inputValue);\n\n    // good\n    const val: number = parseInt(inputValue, 10);\n    ```\n\n  <a name=\"coercion--comment-deviations\"></a><a name=\"20.4\"></a>\n  - [20.4](#coercion--comment-deviations) If for whatever reason you are doing something wild and `parseInt` is your bottleneck and need to use Bitshift for [performance reasons](https://jsperf.com/coercion-vs-casting/3), leave a comment explaining why and what you're doing.\n\n    ```typescript\n    // good\n    /**\n     * parseInt was the reason my code was slow.\n     * Bitshifting the String to coerce it to a\n     * Number made it a lot faster.\n     */\n    const val: number = inputValue >> 0;\n    ```\n\n  <a name=\"coercion--bitwise\"></a><a name=\"20.5\"></a>\n  - [20.5](#coercion--bitwise) **Note:** Be careful when using bitshift operations. Numbers are represented as [64-bit values](https://es5.github.io/#x4.3.19), but bitshift operations always return a 32-bit integer ([source](https://es5.github.io/#x11.7)). Bitshift can lead to unexpected behavior for integer values larger than 32 bits. [Discussion](https://github.com/airbnb/javascript/issues/109). Largest signed 32-bit Int is 2,147,483,647:\n\n    ```typescript\n    2147483647 >> 0; // => 2147483647\n    2147483648 >> 0; // => -2147483648\n    2147483649 >> 0; // => -2147483647\n    ```\n\n  <a name=\"coercion--booleans\"></a><a name=\"20.6\"></a>\n  - [20.6](#coercion--booleans) Booleans:\n\n    ```typescript\n    const age: number = 0;\n\n    // bad\n    const hasAge: boolean = new Boolean(age);\n    const hasAge: boolean = Boolean(age);\n\n    // best\n    const hasAge: boolean = !!age;\n    ```\n\n**[⬆ back to top](#table-of-contents)**\n\n## Naming Conventions\n\n  <a name=\"naming--descriptive\"></a><a name=\"21.1\"></a>\n  - [21.1](#naming--descriptive) Be descriptive with your naming. \n\n    ```typescript\n    // bad\n    const q = () => {\n      // ...\n    };\n\n    // good\n    const query = () => {\n      // ...\n    };\n    ```\n\n  <a name=\"naming--camelCase\"></a><a name=\"21.2\"></a>\n  - [21.2](#naming--camelCase) Use camelCase when naming objects, functions, and instances. \n\n    ```typescript\n    // bad\n    const OBJEcttsssss: Interface = {};\n    const this_is_my_object: Interface = {};\n    const c = () => {};\n\n    // good\n    const thisIsMyObject: Interface = {};\n    const thisIsMyFunction = () => {};\n    ```\n\n  <a name=\"naming--PascalCase\"></a><a name=\"21.3\"></a>\n  - [21.3](#naming--PascalCase) Use PascalCase only when naming constructors or classes. \n\n    ```typescript\n    // bad\n    class user {\n      private name: string;\n\n      constructor(options: Options) {\n        this.name = options.name;\n      }\n    }\n\n    const bad: user = new user({\n      name: 'nope',\n    });\n\n    // good\n    class User {\n      private name: string;\n\n      constructor(options: Options) {\n        this.name = options.name;\n      }\n    }\n\n    const good: User = new User({\n      name: 'yup',\n    });\n    ```\n\n  <a name=\"naming--leading-underscore\"></a><a name=\"21.4\"></a>\n  - [21.4](#naming--leading-underscore) Do not use trailing or leading underscores. \n\n**[⬆ back to top](#table-of-contents)**\n\n## Accessors\n\n  <a name=\"accessors--not-required\"></a><a name=\"22.1\"></a>\n  - [22.1](#accessors--not-required) Accessor functions for properties are not required.\n\n  <a name=\"accessors--no-getters-setters\"></a><a name=\"22.2\"></a>\n  - [22.2](#accessors--no-getters-setters) Do use TypeScript getters/setters.\n\n    ```typescript\n    // good\n    class Dragon {\n      get age(): number {\n        // ...\n      }\n\n      set age(value: number): number {\n        // ...\n      }\n    }\n    ```\n**[⬆ back to top](#table-of-contents)**\n\n## Events\n\n  <a name=\"events--hash\"></a><a name=\"23.1\"></a>\n  - [23.1](#events--hash) When attaching data payloads to events (whether DOM events or something more proprietary like Backbone events), pass a hash instead of a raw value. This allows a subsequent contributor to add more data to the event payload without finding and updating every handler for the event. For example, instead of:\n\n    ```typescript\n    // bad\n    $(this).trigger('listingUpdated', listing.id);\n\n    // ...\n\n    $(this).on('listingUpdated', (e: JQueryEvent, listingId: string) => {\n      // do something with listingId\n    });\n    ```\n\n    prefer:\n\n    ```typescript\n    // good\n    $(this).trigger('listingUpdated', { listingId: listing.id });\n\n    // ...\n\n    $(this).on('listingUpdated', (e: JQueryEvent, data: { listingId: string; }) => {\n      // do something with data.listingId\n    });\n    ```\n  **[⬆ back to top](#table-of-contents)**\n\n## jQuery\n\n  <a name=\"jquery--dollar-prefix\"></a><a name=\"24.1\"></a>\n  - [24.1](#jquery--dollar-prefix) Prefix jQuery object variables with a `$` if they are outside `ui` elements bind to a Marionette View. \n\n    ```typescript\n    // bad\n    const sidebar: JQueryElement = $('.sidebar');\n\n    // good\n    const $sidebar: JQueryElement = $('.sidebar');\n\n    // good\n    const $sidebarBtn: JQueryElement = $('.sidebar-btn');\n    ```\n\n  <a name=\"jquery--cache\"></a><a name=\"24.2\"></a>\n  - [24.2](#jquery--cache) Cache jQuery lookups whenever possible.\n\n    ```typescript\n    // bad\n    function setSidebar() {\n      $('.sidebar').hide();\n\n      // ...\n\n      $('.sidebar').css({\n        'background-color': 'pink',\n      });\n    }\n\n    // good\n    function setSidebar() {\n      const $sidebar: JQueryElement = $('.sidebar');\n      $sidebar.hide();\n\n      // ...\n\n      $sidebar.css({\n        'background-color': 'pink',\n      });\n    }\n    ```\n\n  <a name=\"jquery--queries\"></a><a name=\"24.3\"></a>\n  - [24.3](#jquery--queries) For DOM queries use Cascading `$('.sidebar ul')` or parent > child `$('.sidebar > ul')`. [jsPerf](http://jsperf.com/jquery-find-vs-context-sel/16)\n\n  <a name=\"jquery--find\"></a><a name=\"24.4\"></a>\n  - [24.4](#jquery--find) Use `find` with scoped jQuery object queries.\n\n    ```typescript\n    // bad\n    $('ul', '.sidebar').hide();\n\n    // bad\n    $('.sidebar').find('ul').hide();\n\n    // good\n    $('.sidebar ul').hide();\n\n    // good\n    $('.sidebar > ul').hide();\n\n    // good\n    $sidebar.find('ul').hide();\n    ```\n**[⬆ back to top](#table-of-contents)**\n\n<a name=\"ecmascript-6-styles\"></a>\n## ECMAScript 6+ (ES 2015+) Styles\n\n  <a name=\"tc39-proposals\"></a>\n  - [25.1](#tc39-proposals) Do not use [TC39 proposals](https://github.com/tc39/proposals) that have not reached stage 3.\n\n    > Why? [They are not finalized](https://tc39.github.io/process-document/), and they are subject to change or to be withdrawn entirely. We want to use JavaScript, and proposals are not JavaScript yet.\n\n**[⬆ back to top](#table-of-contents)**\n\n## Testing\n\n  <a name=\"test-jasmine\"></a>\n  - [26.1](#test-jasmine) We use [Jasmine](https://jasmine.github.io/) at Coveo, and combine it with [Enzyme](http://airbnb.io/enzyme/) when testing React components. \n\n  <a name=\"test-everything\"></a>\n  - [26.2](#test-everything) You should be writing tests for all new code you write. 100% test coverage is a good goal to strive for, even if it's not always practical to reach it.\n\n    > Why? Testing aggressively gives you solid proofs that your system/application will work the way you want. Plus, if new code breaks your application, it will be much easier to find out why it happened if the code base is well tested.\n\n\n  <a name=\"regression-test\"></a>\n  - [26.3](#regression-test) Whenever you fix a bug, _write a regression test_. In other words, add additional unit tests proving that the bug is really fixed and unlikely to break again in the future.\n  \n    > Why? A bug fixed without a regression test is almost certainly going to break again in the future.\n\n  <a name=\"test-mocks\"></a>\n  - [26.4](#test-mocks) Use mocks to mock objects, and create them in their own files.\n    > Why? Having your mocks outside your test files makes your tests more readable. \n  \n  <a name=\"test-spies\"></a>\n  - [26.5](#test-spies) Name your spies with the name of the entity you want to spy on (be it a method or property) following with the _Spy_ suffix. For example, if you want to spy on a method called `renderChildren`, you should name your spy `renderChildrenSpy`.\n    > Why? Naming your spies makes your tests easier to understand and shorter to write overall. Adding the Spy suffix makes the person who reads your code aware that it is a \"spied upon\" entity.\n\n  <a name=\"test-matchers\"></a>\n  - [26.6](#test-matchers) Prefer built-in jasmine matchers (`toBeDefined`, `toEqual`, `toBe`, `toContain`, etc) before custom matchers, except for `toBeTruthy` and `toBeFalsy`. \n    > Why? Jasmine's matchers are robust and give clear information in the logs if your test breaks, which make things easier to debug. \n\n**[⬆ back to top](#table-of-contents)**\n\n## Reviewing  \n\n  <a name=\"review-daily\"></a>\n  - [27.1](#review-daily) Review code of your peers **daily** as long as there are pull requests to review. No, this won't affect your productivity negatively, it will speed it up. \n    > Why? Receiving or giving code reviews at least daily speeds up the feedback rate for each team member and consequently speeds up the rate at which your team merges its pull requests without losing in quality. Reviewing and merging pull requests at a standard and predictible pace gives momentum to the team. Adopting this habit can also free your brain from thinking about tasks that have remained pending in a \"review\" state for multiple days without having received any feedback. \n\n  <a name=\"review-fully\"></a>\n  - [27.2](#review-fully) Consider a complete code review as having read (and hopefully understood) each line of code contained in the pull request being reviewed, including its unit tests. If there is a demo (in the form of a live demo, video or image), make sure you thoroughly tested it or seen it. If the pull request to review is long and you think it will take more than an hour to do, be disciplined, and do it anyway.\n    > Why? Half a review is no review. Be thorough and genuinely critical in your review, but always remain respectful.\n\n  <a name=\"review-pragmatically\"></a>\n  - [27.3](#review-pragmatically) Avoid looking for small or unimportant issues. As a rule of thumb, seek \"good enough\" code, and not perfection (it's subjective anyway). If the code fits the standards described in this document, don't go overboard to prove a point. You can offer suggestions, but don't insist on them being implemented to approve features of your peers. \n    > Why? Nit picking and perfectionism kills development speed. \n\n## Being Reviewed \n\n  <a name=\"reviewed-be-steady\"></a>\n  - [28.1](#reviewed-be-steady) Avoid letting your pull requests pending \"in review\" for too long. As a rule of thumb, focus on applying reviews and closing your on going pull requests before starting other features. \n    > Why? It keeps discussions around pull requests more lively and on point. It's easy to lose some context about a pull request when you did not touch it for a couple of days.\n\n  <a name=\"reviewed-explain-things\"></a>\n  - [28.2](#reviewed-unconscious-lazyness) Provide written explanations on what complex parts of your code do. Provide written explanations on changes you've made after receiving reviews. And, all explanations should preferably appear in the pull request itself.\n\n    > Why? Explanations help everybody understand better your pull request and its advancements. Having them all in the pull request allow everyone to see the explanations (as opposed to direct messages between two team members on Slack).\n\n  <a name=\"reviewed-unconscious-lazyness\"></a>\n  - [28.3](#reviewed-unconscious-lazyness) Combat lazyness. It might sound obvious when you are fresh into a new feature. However, after a couple of days (or weeks) into one, things can get psychologically more complex. Always stay self-aware of whether you are arguing against doing something because you are tired of a feature, or really because it is not worthwile to do at this point.    \n    > Why? Regardless of the state you're in, quality should always be the first priority.\n\n  <a name=\"reviewed-pragmatically\"></a>\n  - [28.4](#reviewed-pragmatically) Avoid debating over small or unimportant issues. If, in your view, you received nit picking comments on your pull request and someone insists on you making changes, apply them quickly and move on.     \n\n    > Why? Sometimes things are just subjective and arguing thus becomes a time-consuming dead end. The sooner the reviewer or the reviewee recognizes the situation, the better. \n\n## TypeScript \n#### Interface\n\n  <a name=\"interface-naming\"></a>\n  - [29.1](#interface-naming) Use `PascalCase` when naming your interfaces, and `camelCase` for their members.\n\n  <a name=\"interface-no-i\"></a>\n  - [29.2](#interface-no-i) Do not prefix your interfaces with `I`.  \n    > Why? Unconventional. Important interfaces (like `Window`, `Document`) are usually not defined with the `I` prefix.\n\n#### Type\n\n  <a name=\"type-naming\"></a>\n  - [29.3](#types-naming) Use `PascalCase` when naming your types, and `camelCase` for their members.\n\n#### Enum\n\n  <a name=\"enum-naming\"></a>\n  - [29.4](#enum-naming) Use `PascalCase` when naming your enums, and `camelCase` for their members.\n\n#### Function \n  <a name=\"function-return\"></a>\n  - [29.5](#function-return) Avoid specifying the returned type if the function can return anything (`any`) or nothing.\n\n### Namespace\n  <a name=\"namespace-avoid\"></a>\n  - [29.7](#namespace-avoid) Do not use namespaces. Use [modules](https://www.typescriptlang.org/docs/handbook/modules.html).  \n\n## Libraries and Frameworks \n\nThe following list is an overview of the main frameworks and libraries we use when developping for the Coveo Cloud Platform. You can dig deeper by clicking on the links of each library or framework listed:  \n  \n- [Backbone.js](http://backbonejs.org/)\n- [Marionette.js](https://marionettejs.com/)\n- [EJS](http://www.embeddedjs.com/)\n- [React](https://facebook.github.io/react/) \n- [Redux](http://redux.js.org/docs/introduction/)\n- [Underscore.js](http://underscorejs.org/)\n- [jQuery](https://jquery.com/)\n- [Moment.js](https://momentjs.com/)\n- [URI.js](https://medialize.github.io/URI.js/)\n- [Polyglot.js](http://airbnb.io/polyglot.js/)  \n- [Webpack](https://webpack.js.org/)  \n- [Gulp](https://gulpjs.com/)  \n- [npm](https://docs.npmjs.com/)  \n\n**A few rules of thumb:**\n  \n- Use \"native\" features of Backbone/Marionette and React/Redux whenever you can. Only defaults to using jQuery if and only if your problem cannot be solved with the main frameworks and architecture we use.  \n- Always use EJS for HTML templating if you are working with Backbone/Marionette.  \n- Use Underscore.js as much as it pleases you. \n- If you are working on new components or complex features, favor React/Redux over Backbone/Marionette as your framework of choice.\n\n## Notes on Legacy Code \n\nAs for any project that has lived for a long period of time, you may find some places in the code base where the code does not respect some standards described above. In this case, do refactor the code if it is related to your current task, or if you think it could represent a potential security or bug threat. Otherwise, you can leave the code as it is.\n  \n\n## Remaining Sections\nYou can refer to the original [Airbnb Style Guide](https://github.com/airbnb/javascript) for the remaining sections if you want, although they are really not a required read by our team.  \n  \n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/coveo/tsjs.git"
  },
  "scripts": {
    "test": "node -e 'console.log(\"No script added yet, add one.\");'"
  },
  "version": "0.3.3"
}
